# Policy

Policy отличная штука, но из-за того, что она очень глубоко спрятана за фасадом, 
её реализацию не вытащить на поверхность. Когда мы вызываем `Gate`, 
авторизуем метод или ресурсный контроллер — мы вынуждены опираться только 
на нашу внимательность и память — среда разработки не подскажет правильность аргументов.

Разумеется, это [можно побороть](gate.php), но [результат не оправдывает средства](gate.md). Поэтому ограничиваемся советами.

**Во-первых**, я рекомендую всегда возвращать ответ в виде `Response` объекта с текстовым описанием:

```php
namespace App\Policies;

class PostPolicy
{
    use Responsable;
    
    public function update(User $user, Post $post): Response
    {
        return $user->is($post->author) ?
            Response::allow('Автор может редактировать запись') :
            Response::deny('Только автор может редактировать запись');
    }
}
```

Такой код является максимально очевидным, он сам себя документирует.

**Во-вторых**, если проект сложный и права доступа сложные, 
мы можем оставлять для себя подсказки в виде ссылок на методы `Policy` в местах, где они используются. 
Например, в контроллерах.

Возьмем пример с `Commentable`, который мы [рассматривали ранее](contracts.md). 
У нас будет примерно такой `Policy`:

```php
namespace App\Policies;

class CommentPolicy
{
    use Responsable;
    
    public function create(User $user, Commentable $commentable): Response
    {
        // etc
    }
}
```

Поскольку сигнатура методов в таком `Policy` отличается от стандартной, неплохо будет оставить подсказку в месте его вызова. 
При такой разметке мы сможем быстро перейти к реализации метода, а из реализации метода — быстро увидеть места его вызова. 

```php
namespace App\Http\Controllers;

class CommentController extends Controller
{

    /**
     * @uses App\Policies\CommentPolicy::create()
     */
    public function store(Request $request, Post $post) {
        $this->authorize('create', [Comment::class, $post]);
        
        // etc
    }
}
```

**В-третьих**, если мы делаем [Event Driven User Interface](event_driven_ui.md), то нам надо передавать права доступа во фронт.
Лучше всего это делать с помощью тех же самых `Response` объектов.

Вот, например, ресурс со списком комментариев, и мы в него добавляем информацию о том, может ли пользователь добавить новый комментарий:

```php
[
    'create' => Gate::inspect('create', [Comment::class, $this->commentable])->toArray(),
]
```

На фронте окажется не только информация о правах доступа, но и причина отказа, 
которую можно использовать при построении пользовательского интерфейса:

```php
[
    'allowed' => true|false,
    'message' => 'The reason why',
]
```

## В заключение

Совет прост: если чувствуете, что сложность проекта нарастает и переполняет возможности
вашей человеческой оперативной памяти — оставляете себе подсказки. Ну а если нет, то нет.